# SOCKET：高级主题
### 流式套接字上的部分读和部分写
如果套接字上可用数据比read调用中请求的数据少，可能出现部分读的情况，如果没有足够的缓冲区来传输所有请求的字节，可能出现部分写的情况；如果read返回的字节少于请求的数量，或者阻塞式的write在完成部分数据传输后被信号处理程序中断，有时候需要重新调用系统调用来完成全部数据的传输，自定义的两个函数
readn和writen

```c
ssize_t readn(int fd,void*buffer,size_t n){
    ssize_t numRead;
    char*buf;
    buf = buffer;
    for(size_t toRead = 0;toRead < n;){
        numRead = read(fd,buf,n - toRead);
        if(numRead == 0){
            return toRead;
        }
        if(numRead == -1){
            if(errno == EINTR){// 系统调用被信号中断，重试
                continue;
            }else{
                return -1;
            }
        }
        toRead += numRead;
        buf += numRead;// 把指针往后移，跳过已经读取的部分。
    }
    return toRead;
}
ssize_t writen(int fd,const void* buffer,size_t n){
    ssize_t numWritten;
    const char*buf;
    buf = buffer;
    for(size_t toWritten = 0;toWritten < n;){
        numWritten = write(fd,buf,n - toWritten);
        if(numWritten <= 0){
            if(numWritten == -1 && errno == EINTR){
                continue;
            }else{
                return -1;
            }
        }
        toWritten += numWritten;
        buf += numWritten;
    }
    return toWritten;
}
```



### shutdown()系统调用
```c
#include <sys/socket.h>
int shutdown(int sockfd,int how);
```
how 的值可以指定为如下几种:
- SHUT_RD:关闭连接的读端。再调用 `recv()` 会立即返回 0（像对方已经关闭一样）。数据仍然可以写入到套接字上。（本地不能再接收数据，但可以继续发送）（在 UNIX 域流式套接字上执行了 SHUT_RD 操作后，对端应用程序将接收到一个 SIGPIPE 信号，如果继续尝试在对端套接字上做写操作的话将产生 EPIPE 错误。）
- SHUT_WR:关闭连接的写端。你不能再 `send()` 数据（会返回错误），但仍然可以继续接收数据
- SHUT_RDWR：将连接的读端和写端都关闭。这等同于先执行 SHUT_RD，跟着再执行一次 SHUT_WR。

shutdown并不会关闭文件描述符，要关闭文件描述符，必须另外调用close

### 专门用于套接字的系统调用：recv()和send()

```c
ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);
// 若成功，返回发送的字节数，若出错，返回-1
// 类似于write，使用send时套接字必须已经连接，buf和nbytes与write含义相同
// send发送成功，只能说明数据已经被无错误的发送到网络驱动程序了，对端不一定接收到了
// 对于字节流协议，send会阻塞直到整个数据传输完毕

// flags的标志由系统实现
MSG_DONTROUTE: 告诉内核，目标主机在本地网络，不用查路由表
MSG_DONTWAIT: 将单个I／O操作设置为非阻塞模式
MSG_OOB:      指明发送的是带外信息
MSG_MORE:     效果如同套接字选项TCP_CORK，对于UNIX域套接字没有效果
MSG_NOSIGNAL: 在已连接的流式套接字上发送数据时对端已经关闭了，指定该标记不会产生SIGPIPE信号
MSG_EOF:      发送数据后关闭套接字的发送端

ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);
// 若成功，返回数据的字节数，若无可用数据或对方已经结束，返回0，若出错，返回-1

// flags的含义：       
MSG_DONTWAIT：	仅本操作非阻塞 	         	  
MSG_OOB：　　　发送或接收带外数据	        
MSG_PEEK：    窥看下一条消息而不读取  	 
MSG_WAITALL： 等待所有数据 	      	 
MSG_TRUNC：   数据被截断，也返回实际长度  
```

### 系统调用：sendfile()

像 Web 服务器和文件服务器这样的应用程序常常需要将磁盘上的文件内容不做修改地通
过（已连接）套接字传输出去：

```c
while ((n = read(diskfilefd, buf, BUF_SIZE)) > 0)
    write(sockfd, buf, n);
```

如果文件很大，可能需要多次调用这两个系统调用，很不高效，可以直接将磁盘文件拷贝到套接字上，而不经过用户空间（buf），这种技术称为零拷贝传输

```c
#include <sys/sendfile.h>

ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
// 返回值：若成功，返回传输的字节，若出错，返回-1
// out_fd指向套接字，in_fd指向的文件必须可以进行mmap()
// 可以使用此接口将数据从文件传输到套接字上，但是反过来不行，也不能通过此接口在两个套接字之间传输数据
```

```c
int fd = open("index.html", O_RDONLY);
struct stat st;
fstat(fd, &st);
sendfile(sockfd, fd, NULL, st.st_size);
```

#### TCP_CORK 套接字选项

要进一步提高 TCP 应用使用 sendfile()时的性能，采用 Linux 专有的套接字选项 TCP_CORK常常会很有帮助。

当在 TCP 套接字上启用了 TCP_CORK 选项后，之后所有的输出都会缓冲到一个单独的 TCP报文段中