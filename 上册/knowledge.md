操作系统的核心—内核
===
### 内核态和用户态:
$\color{red}{用户态下运行时，CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。}$
$\color{blue}{当运行于核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存。}$

进程也闹不清自己所访问的文件“居于”磁盘驱动器的何处，只是通过名称来引用文件而已。
进程本身无法创建出新进程，进程也不能与计算机外接的输入输出设备直接通信。

### shell
shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。
内核维护着一套单根目录结构，以放置系统的所有文件。
这一目录层级的根基就是名为“/”的根目录。所有的文件和目录都是根目录的“子孙”。
文件类型:在文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，人们常称之为“普通文件”或“纯文本文件”
，以示与其他种类的文件有所区别。其他文件类型包括设备、管道、套接字、目录以及符号链接。
术语“文件”常用来指代任意类型的文件，不仅仅指普通文件。

### 目录
目录是一种特殊类型的文件，内容采用表格形式，数据项包括文其一是两个
进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。文件名以及对相应文件的引用。`文件名+引用`的组合被称为链接。
每个目录至少包含两条记录：.和..，前者是指向目录自身的链接，后者是指向其上级目录------父目录的链接。
一个符号链接对应着目录中内容为“文件名+指针”的一条记录，指针指向的**文件内容**（及该文件所属数据块存储的内容）为另一个文件名的字符串.
所谓“另一文件”通常被称为符号链接的目标，人们一般会说符号链接“指向”或“引用”目标文件。
多数情况系统，调用用到了路径名，内核会自动解除（按照）该路径名中`符号链接的引用`，以符号
链接所指向的`文件名`来替换符号链接。若符号链接的目标文件自身也是一个符号链接，那么上述过程会以递归方式重复下去。
`为了应对可能出现的循环引用，内核对解除引用的次数作了限制。`如果符号链接指向的文件并不存在，那么可将该链接视为**空链接（dangling link）**

SUSv3 将这 65 个字符的集合[``-._a-zA-Z0-9``]称为可移植文件名字符集
对于可移植文件名字符集以外的字符，由于其可能会在 shell、正则表达式或其他场景中具有特殊含义，故而应避免在文件名中使用。如在上述环境中出现了包含特殊含义字符的
文件名，则需要进行转义，即对此类字符进行特殊标记（一般会在特殊字符前插入一个“\”）
此外，还应避免以连字符（“-”）作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。
- `绝对路径名` 以“/”开始，指明文件相对于根目录的位置。
- `相对路径名` 定义了相对于进程当前工作目录（见下文）的文件位置，与绝对路径名相比，相对路径名缺少了起始的“/”。

内核只提供一种文件类型：**字节流序列**，在处理磁盘文件、磁盘或磁带设备时，可通过 lseek()系统调用来随机访问。
UNIX 系统没有文件结束符的概念，<u>读取文件时如无数据返回，便会认定抵达文件末尾。</u>
#### 文件描述符
I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。
shell 启动的进程会继承 3 个已打开的文件描述符：`描述符 0 为标准输入`，指代为进程提供输入的文件；`描述符 1 为标准输出`，指代供进程写入输出的文件；`描述符 2 为标准错误，`
指代供进程写入错误消息或异常通告的文件。在交互式 shell 或程序中，上述三者一般都指向终端。在 stdio 函数库中，这几种描述符分别与文件流<u> stdin、stdout 和 stderr 相对应。</u>
### 2.6程序
#### 过滤器
从 stdin 读取输入，加以转换，再将转换后的数据输出到 stdout，常常将拥有上述行为的程序称为过滤器，cat、grep、tr、sort、wc、sed、awk 均在其列。
>进程的内存布局:逻辑上将一个进程划分为以下几部分（也称为段）。
> - 文本：程序的指令。
> - 数据：程序使用的静态变量。
> - 堆：程序可从该区域动态分配额外内存。
> - 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。
> 
进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。内核通过对父进程的复制来创建子进程。
子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。（在内存中被标记为只读的程序文本段则由父、子进程共享。）
然后，子进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统 **调用 execve()去加载并执行一个全新程序。** execve()会销毁现有的文本段、数
据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。
>在函数间差异无关宏旨的场合，本书会用符号exec()作为这些库函数的统称。不过，请读者牢记，实际上根本不存在名为 exec()的库函数。

每一进程都有一个唯一的整数型进程标识符（PID）。此外，每一进程还具有一个父进程标识符（PPID）属性，用以标识请求内核创建自己的进程。
终止一个进程：其一，进程可使用_exit()系统调用（或相关的exit()库函数），请求退出；其二，向进程传递信号，将其“杀死”;进程都会生成“终止状态”，一个非负小整数，可供父进程的 wait()系统调用检测。
调用_exit()进程会指明自己的终止状态。若由信号来“杀死”进程，则会根据导致进程“死亡”的信号类型来设置进程的终止状态。
（有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。）
根据惯例，终止状态为 0 表示进程结束，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。

### 进程的用户和组标识符（凭证）
>每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)
>真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
>有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
>补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。

始于内核 2.2，Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。
传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。

### init进程——所有进程之父
该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。init 进程的进程号总为 1，且总是以超级用户权限运行。
只有关闭系统才能终止该进程。任务是创建并监控系统运行所需的一系列进程。
### 守护进程
- “长生不老”守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”
- 守护进程在后台运行，且无控制终端供其读取或写入数据。
### 环境列表
在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令）
C 语言程序可使用外部变量（char **environ）来访问环境，而库函数也允许进程去获取或修改自己环境中的值。
### 资源限制
每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用` setrlimit()`，进程可为自己消耗的各类资源设定一个上限。
此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）软限制的调整上限。
非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。
### 2.8内存映射
调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。
- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。
- 相映成趣的是并无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

某一进程所映射的内存可以与其他进程的映射共享:其一是两个进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。
- 当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见取决于创建映射时所传入的标志参数。
- 若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；
- 若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。

内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。
### 静态库和共享库
#### 静态库
静态库是对已编译目标模块的一种结构化整合。要使用静态库中的函数，需要在创建程序的链接命令中指定相应的库。
- 在不同的可执行文件中，可能都存有相同目标代码的副本，这是对磁盘空间的浪费。同理，调用同一库函数的程序，若均以静态链接方式生成，且又于同时加以执行，这会造成内存浪费，因为每个程序所调用的函数都各有一份
- 副本驻留在内存中，此其二。此外，如果对库函数进行了修改，需要重新加以编译、生成新的静态库，而所有需要调用该函数“更新版”的应用，都必须与新生成的静态库重新链接。
#### 共享库——解决静态库所存在的问题。
- 将程序链接到共享库，链接器不会把库中的目标模块复制到可执行文件中，而是在可执行文件中写入一条记录，以表明可执行文件在运行时需要使用该共享库。
- 运行时将可执行文件载入内存，名为“动态链接器”的程序会确保将可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中相应的函数定义关联起来。在运行时，共享库代码在内存中只需保留一份，且可供所有运行中的程序使用。
- 能确保各类程序及时使用到函数的最新版本，只需将带有函数新定义体的共享库重新加以编译即可，程序会在下次执行时自动使用新函数。
### 进程间通信及同步
有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制
> - 信号（signal），用来表示事件的发生。
>- 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。`|的主要作用是将一个命令的输出作为另一个命令的输入`
>- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
>- 消息队列，用于在进程间交换消息（数据包）。
>- 信号量（semaphore），用来同步进程动作。
>- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。
### 信号
内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。
在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。
收到信号时，进程会根据信号采取如下动作之一。
>-  忽略信号。
>- 被信号“杀死”。
>- 先挂起，之后再被专用信号唤醒。

大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号或者建立自己的信号处理器。信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。
# 文件 I/O：通用的 I/O 模型
4-1.c
- O_RDONLY 以只读方式打开文件
- O_WRONLY 以只写方式打开文件
- O_RDWR 以读写方式打开文件
-------
- O_CLOEXEC设置 close-on-exec 标志（自 Linux 2.6.23 版本开始）v4
- O_CREAT若文件不存在则创建之，文件以只读方式打开，还需要提供 mode 参数v3
- O_DIRECT无缓冲的输入/输出O_DIRECTORY如果 pathname 不是目录，则失败v4
- O_EXCL结合 O_CREAT 参数使用，专门用于创建文件v3
- O_LARGEFILE在 32 位系统中使用此标志打开大文件- O_NOATIME调用 read()时，不修改文件最近访问时间（自 Linux 2.6.8版本开始）
- O_NOCTTY不要让 pathname（所指向的终端设备）成为控制终端v3
- O_NOFOLLOW对符号链接不予解引用v4
- O_TRUNC截断已有文件，使其长度为零v3
-------------
- O_APPEND总在文件尾部追加数据
- O_ASYNC当 I/O 操作可行时，产生信号（signal）通知进程
- O_DSYNC提供同步的 I/O 数据完整性（自 Linux 2.6.33 版本开始）v3
- O_NONBLOCK以非阻塞方式打开v3
- O_SYNC以同步方式写入文件v3

### open()调用所返回的文件描述符数值
如果调用 open()成功，必须保证其返回值为**进程未用文件描述符中数值最小者**。可以利用该特性以特定文件描述符打开某一文件。
- O_RDONLY、O_WRONLY 和 O_RDWR 标志均在此列，调用 open()时，上述三者在 flags 参数中不能同时使用，只能指定其中一种。调用fcntl()的 F_GETFL 操作能够检索文件的访问模式（见 5.3 节）。
- 文件创建标志：这些标志在表 4-3 中位于第二部分，其控制范围不拘于 open()调用行为的方方面面，还涉及后续 I/O 操作的各个选项。这些标志**不能检索，也无法修改**。
- 已打开文件的状态标志：这些标志是表 4-3 中的剩余部分，使用 fcntl()的 F_GETFL 和F_SETFL 操作可以分别检索和修改此类标志。有时干脆将其称之为**文件状态标志**。
- 调用 open()时指定 O_ASYNC 标志没有任何实质效果。
- fork用于创建一个新的进程，父进程返回一个大于0,子进程返回0,失败返回-1
  
### open()函数的错误
- EACCES文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原因有目录权限的限制、文件不存在并且也无法创建该文件。
- EISDIR所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。
- EMFILE进程已打开的文件描述符数量达到了进程资源限制所设定的上限
- ENFILE文件打开数量已经达到系统允许的上限。
- ENOENT要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存在（空链接）。
- EROFS所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。
- ETXTBSY所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）
  
### creat()系统调用
需要<fcntl.h>
creat()系统调用根据 pathname 参数创建并打开一个文件，若文件已存在，则打开文件，并清空文件内容，将其长度清 0。creat()返回一文件描述符，供后续系统调用使用。
等价于：
```c
fd = open(pathname,O_WRONLY | O_CREAT | O_TRUNC,mode)
```
现在不太用
### 读取文件内容：read()
**从文件描述符 fd 所指代的打开文件中读取数据。**
```c
#include<unistd.h>
ssize_t read(int fd,void* buffer,size_t count);
```
- count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。
- 如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
- 一次 read()调用所读取的字节数可以小于请求的字节数。
- 默认情况下从终端读取字符，一遇到换行符（\n），read()调用就会结束。
### 数据写入文件：write()
**将数据写入一个已打开的文件中。**
```c
#include<unistd.h>
ssize_t write(int fd,void* buffer,size_t count);
```
- write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。
- write()调用成功并不能保证数据已经写入磁盘。因为为了减少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作，
### 关闭文件：close()
**调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当一进程终止时，将自动关闭其已打开的所有文件描述符。**
```c
#include<unistd.h>
int close(int fd);
```
- 显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可读性，也更可靠
- **文件描述符属于有限资源，因此文件描述符关闭失败可能会导致一个进程将文件描述符资源消耗殆尽。**
### 改变文件偏移量：lseek()
- 每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 read()或 write()操作的文件起始位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。
- 文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按顺序递进，对文件进行操作。
- 针对文件描述符 fd 参数所指代的已打开文件，lseek()系统调用依照 offset 和 whence 参数值调整该文件的偏移量。
- offset 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型）whence 参数则表明应参照哪个基点来解释 offset 参数应为以下其中之一。
> - SEEK_SET 将文件偏移量设置为从文件头部起始点开始的 offset 个字节。
> - SEEK_CUR 相对于当前文件偏移量，将文件偏移量调整 offset 个字节 。
> - SEEK_END将文件偏移量设置为起始于文件尾部的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起。
```c
#include<unistd.h>
off_t lseek(int fd,off_t offset,int whence);
```
- lseek()并不适用于所有类型的文件。不允许将 lseek()应用于管道、FIFO、socket 或者终端。一旦如此，调用将会失败，并将 errno 置为 ESPIPE。
- O_APPEND 会导致内核忽略应用程序的文件偏移量，强制将每次写入的数据追加到文件末尾。
### 文件空洞
- 从文件结尾后到新写入数据间的这段空间被称为文件空洞.文件空洞中是存在字节的，读取空洞将返回以 0（空字节）填充的缓冲区。
- 文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。
- 文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。eg : 核心转储文件
### 通用 I/O 模型以外的操作：ioctl()
```C
#include<sys/ioctl.h>
int ioctl(int fd,int requst,.../*argp*/);
```
- fd 参数为某个设备或文件已打开的文件描述符，request 参数指定了将在 fd 上执行的控制操作。具体设备的头文件定义了可传递给 request 参数的常量。
- ioctl()调用的第三个参数采用了标准 C 语言的省略符号（...）来表示（称之为 argp），可以是任意数据类型。ioctl()根据 request 的参数值来确定 argp 所期望的类型。通常情况下，argp是指向整数或结构的指针，有些情况下，不需要使用 argp。
# 深入探究文件 I/O
### 原子操作和竞争条件
竞争状态的情形:操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程 获得 CPU 使用权的先后相对顺序
### 文件控制操作：fcntl()
```c
#include<fcntl.h>
int fcntl(int fd,int cmd,...);
```
cmd 参数所支持的操作范围很广。fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。
### 打开文件的状态标志
- fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为F_GETFL。
- 可以使用 fcntl()的 F_SETFL 命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT。
- 