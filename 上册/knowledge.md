操作系统的核心—内核
===
### 内核态和用户态:
$\color{red}{用户态下运行时，CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。}$
$\color{blue}{当运行于核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存。}$

进程也闹不清自己所访问的文件“居于”磁盘驱动器的何处，只是通过名称来引用文件而已。
进程本身无法创建出新进程，进程也不能与计算机外接的输入输出设备直接通信。

### shell
shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。
内核维护着一套单根目录结构，以放置系统的所有文件。
这一目录层级的根基就是名为“/”的根目录。所有的文件和目录都是根目录的“子孙”。
文件类型:在文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，人们常称之为“普通文件”或“纯文本文件”
，以示与其他种类的文件有所区别。其他文件类型包括设备、管道、套接字、目录以及符号链接。
术语“文件”常用来指代任意类型的文件，不仅仅指普通文件。

### 目录
目录是一种特殊类型的文件，内容采用表格形式，数据项包括文其一是两个
进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。文件名以及对相应文件的引用。`文件名+引用`的组合被称为链接。
每个目录至少包含两条记录：.和..，前者是指向目录自身的链接，后者是指向其上级目录------父目录的链接。
一个符号链接对应着目录中内容为“文件名+指针”的一条记录，指针指向的**文件内容**（及该文件所属数据块存储的内容）为另一个文件名的字符串.
所谓“另一文件”通常被称为符号链接的目标，人们一般会说符号链接“指向”或“引用”目标文件。
多数情况系统，调用用到了路径名，内核会自动解除（按照）该路径名中`符号链接的引用`，以符号
链接所指向的`文件名`来替换符号链接。若符号链接的目标文件自身也是一个符号链接，那么上述过程会以递归方式重复下去。
`为了应对可能出现的循环引用，内核对解除引用的次数作了限制。`如果符号链接指向的文件并不存在，那么可将该链接视为**空链接（dangling link）**

SUSv3 将这 65 个字符的集合[``-._a-zA-Z0-9``]称为可移植文件名字符集
对于可移植文件名字符集以外的字符，由于其可能会在 shell、正则表达式或其他场景中具有特殊含义，故而应避免在文件名中使用。如在上述环境中出现了包含特殊含义字符的
文件名，则需要进行转义，即对此类字符进行特殊标记（一般会在特殊字符前插入一个“\”）
此外，还应避免以连字符（“-”）作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。
- `绝对路径名` 以“/”开始，指明文件相对于根目录的位置。
- `相对路径名` 定义了相对于进程当前工作目录（见下文）的文件位置，与绝对路径名相比，相对路径名缺少了起始的“/”。

内核只提供一种文件类型：**字节流序列**，在处理磁盘文件、磁盘或磁带设备时，可通过 lseek()系统调用来随机访问。
UNIX 系统没有文件结束符的概念，<u>读取文件时如无数据返回，便会认定抵达文件末尾。</u>
#### 文件描述符
I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。
shell 启动的进程会继承 3 个已打开的文件描述符：`描述符 0 为标准输入`，指代为进程提供输入的文件；`描述符 1 为标准输出`，指代供进程写入输出的文件；`描述符 2 为标准错误，`
指代供进程写入错误消息或异常通告的文件。在交互式 shell 或程序中，上述三者一般都指向终端。在 stdio 函数库中，这几种描述符分别与文件流<u> stdin、stdout 和 stderr 相对应。</u>
### 2.6程序
#### 过滤器
从 stdin 读取输入，加以转换，再将转换后的数据输出到 stdout，常常将拥有上述行为的程序称为过滤器，cat、grep、tr、sort、wc、sed、awk 均在其列。
>进程的内存布局:逻辑上将一个进程划分为以下几部分（也称为段）。
> - 文本：程序的指令。
> - 数据：程序使用的静态变量。
> - 堆：程序可从该区域动态分配额外内存。
> - 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。
> 
进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。内核通过对父进程的复制来创建子进程。
子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。（在内存中被标记为只读的程序文本段则由父、子进程共享。）
然后，子进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统 **调用 execve()去加载并执行一个全新程序。** execve()会销毁现有的文本段、数
据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。
>在函数间差异无关宏旨的场合，本书会用符号exec()作为这些库函数的统称。不过，请读者牢记，实际上根本不存在名为 exec()的库函数。

每一进程都有一个唯一的整数型进程标识符（PID）。此外，每一进程还具有一个父进程标识符（PPID）属性，用以标识请求内核创建自己的进程。
终止一个进程：其一，进程可使用_exit()系统调用（或相关的exit()库函数），请求退出；其二，向进程传递信号，将其“杀死”;进程都会生成“终止状态”，一个非负小整数，可供父进程的 wait()系统调用检测。
调用_exit()进程会指明自己的终止状态。若由信号来“杀死”进程，则会根据导致进程“死亡”的信号类型来设置进程的终止状态。
（有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。）
根据惯例，终止状态为 0 表示进程结束，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。

### 进程的用户和组标识符（凭证）
>每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)
>真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
>有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
>补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。

始于内核 2.2，Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。
传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。

### init进程——所有进程之父
该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。init 进程的进程号总为 1，且总是以超级用户权限运行。
只有关闭系统才能终止该进程。任务是创建并监控系统运行所需的一系列进程。
### 守护进程
- “长生不老”守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”
- 守护进程在后台运行，且无控制终端供其读取或写入数据。
### 环境列表
在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令）
C 语言程序可使用外部变量（char **environ）来访问环境，而库函数也允许进程去获取或修改自己环境中的值。
### 资源限制
每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用` setrlimit()`，进程可为自己消耗的各类资源设定一个上限。
此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）软限制的调整上限。
非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。
### 2.8内存映射
调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。
- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。
- 相映成趣的是并无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

某一进程所映射的内存可以与其他进程的映射共享:其一是两个进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。
- 当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见取决于创建映射时所传入的标志参数。
- 若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；
- 若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。

内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。
### 静态库和共享库
#### 静态库
静态库是对已编译目标模块的一种结构化整合。要使用静态库中的函数，需要在创建程序的链接命令中指定相应的库。
- 在不同的可执行文件中，可能都存有相同目标代码的副本，这是对磁盘空间的浪费。同理，调用同一库函数的程序，若均以静态链接方式生成，且又于同时加以执行，这会造成内存浪费，因为每个程序所调用的函数都各有一份
- 副本驻留在内存中，此其二。此外，如果对库函数进行了修改，需要重新加以编译、生成新的静态库，而所有需要调用该函数“更新版”的应用，都必须与新生成的静态库重新链接。
#### 共享库——解决静态库所存在的问题。
- 将程序链接到共享库，链接器不会把库中的目标模块复制到可执行文件中，而是在可执行文件中写入一条记录，以表明可执行文件在运行时需要使用该共享库。
- 运行时将可执行文件载入内存，名为“动态链接器”的程序会确保将可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中相应的函数定义关联起来。在运行时，共享库代码在内存中只需保留一份，且可供所有运行中的程序使用。
- 能确保各类程序及时使用到函数的最新版本，只需将带有函数新定义体的共享库重新加以编译即可，程序会在下次执行时自动使用新函数。
### 进程间通信及同步
有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制
> - 信号（signal），用来表示事件的发生。
>- 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。`| 主要作用是将一个命令的输出作为另一个命令的输入`
>- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
>- 消息队列，用于在进程间交换消息（数据包）。
>- 信号量（semaphore），用来同步进程动作。
>- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。
### 信号
内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。
在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。
收到信号时，进程会根据信号采取如下动作之一。
>-  忽略信号。
>- 被信号“杀死”。
>- 先挂起，之后再被专用信号唤醒。

大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号或者建立自己的信号处理器。信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。