操作系统的核心—内核
===
### 内核态和用户态:
$\color{red}{用户态下运行时，CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。}$
$\color{blue}{当运行于核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存。}$

进程也闹不清自己所访问的文件“居于”磁盘驱动器的何处，只是通过名称来引用文件而已。
进程本身无法创建出新进程，进程也不能与计算机外接的输入输出设备直接通信。

### shell
shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。
内核维护着一套单根目录结构，以放置系统的所有文件。
这一目录层级的根基就是名为“/”的根目录。所有的文件和目录都是根目录的“子孙”。
文件类型:在文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，人们常称之为“普通文件”或“纯文本文件”
，以示与其他种类的文件有所区别。其他文件类型包括设备、管道、套接字、目录以及符号链接。
术语“文件”常用来指代任意类型的文件，不仅仅指普通文件。

### 目录
目录是一种特殊类型的文件，内容采用表格形式，数据项包括文其一是两个
进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。文件名以及对相应文件的引用。`文件名+引用`的组合被称为链接。
每个目录至少包含两条记录：.和..，前者是指向目录自身的链接，后者是指向其上级目录------父目录的链接。
一个符号链接对应着目录中内容为“文件名+指针”的一条记录，指针指向的**文件内容**（及该文件所属数据块存储的内容）为另一个文件名的字符串.
所谓“另一文件”通常被称为符号链接的目标，人们一般会说符号链接“指向”或“引用”目标文件。
多数情况系统，调用用到了路径名，内核会自动解除（按照）该路径名中`符号链接的引用`，以符号
链接所指向的`文件名`来替换符号链接。若符号链接的目标文件自身也是一个符号链接，那么上述过程会以递归方式重复下去。
`为了应对可能出现的循环引用，内核对解除引用的次数作了限制。`如果符号链接指向的文件并不存在，那么可将该链接视为**空链接（dangling link）**

SUSv3 将这 65 个字符的集合[``-._a-zA-Z0-9``]称为可移植文件名字符集
对于可移植文件名字符集以外的字符，由于其可能会在 shell、正则表达式或其他场景中具有特殊含义，故而应避免在文件名中使用。如在上述环境中出现了包含特殊含义字符的
文件名，则需要进行转义，即对此类字符进行特殊标记（一般会在特殊字符前插入一个“\”）
此外，还应避免以连字符（“-”）作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。
- `绝对路径名` 以“/”开始，指明文件相对于根目录的位置。
- `相对路径名` 定义了相对于进程当前工作目录（见下文）的文件位置，与绝对路径名相比，相对路径名缺少了起始的“/”。

内核只提供一种文件类型：**字节流序列**，在处理磁盘文件、磁盘或磁带设备时，可通过 lseek()系统调用来随机访问。
UNIX 系统没有文件结束符的概念，<u>读取文件时如无数据返回，便会认定抵达文件末尾。</u>
#### 文件描述符
I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。
shell 启动的进程会继承 3 个已打开的文件描述符：`描述符 0 为标准输入`，指代为进程提供输入的文件；`描述符 1 为标准输出`，指代供进程写入输出的文件；`描述符 2 为标准错误，`
指代供进程写入错误消息或异常通告的文件。在交互式 shell 或程序中，上述三者一般都指向终端。在 stdio 函数库中，这几种描述符分别与文件流<u> stdin、stdout 和 stderr 相对应。</u>
### 2.6程序
#### 过滤器
从 stdin 读取输入，加以转换，再将转换后的数据输出到 stdout，常常将拥有上述行为的程序称为过滤器，cat、grep、tr、sort、wc、sed、awk 均在其列。
>进程的内存布局:逻辑上将一个进程划分为以下几部分（也称为段）。
> - 文本：程序的指令。
> - 数据：程序使用的静态变量。
> - 堆：程序可从该区域动态分配额外内存。
> - 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。
> 
进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。内核通过对父进程的复制来创建子进程。
子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。（在内存中被标记为只读的程序文本段则由父、子进程共享。）
然后，子进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统 **调用 execve()去加载并执行一个全新程序。** execve()会销毁现有的文本段、数
据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。
>在函数间差异无关宏旨的场合，本书会用符号exec()作为这些库函数的统称。不过，请读者牢记，实际上根本不存在名为 exec()的库函数。

每一进程都有一个唯一的整数型进程标识符（PID）。此外，每一进程还具有一个父进程标识符（PPID）属性，用以标识请求内核创建自己的进程。
终止一个进程：其一，进程可使用_exit()系统调用（或相关的exit()库函数），请求退出；其二，向进程传递信号，将其“杀死”;进程都会生成“终止状态”，一个非负小整数，可供父进程的 wait()系统调用检测。
调用_exit()进程会指明自己的终止状态。若由信号来“杀死”进程，则会根据导致进程“死亡”的信号类型来设置进程的终止状态。
（有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。）
根据惯例，终止状态为 0 表示进程结束，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。

### 进程的用户和组标识符（凭证）
>每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)
>真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
>有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
>补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。

始于内核 2.2，Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。
传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。

### init进程——所有进程之父
该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。init 进程的进程号总为 1，且总是以超级用户权限运行。
只有关闭系统才能终止该进程。任务是创建并监控系统运行所需的一系列进程。
### 守护进程
- “长生不老”守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”
- 守护进程在后台运行，且无控制终端供其读取或写入数据。
### 环境列表
在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令）
C 语言程序可使用外部变量（char **environ）来访问环境，而库函数也允许进程去获取或修改自己环境中的值。
### 资源限制
每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用` setrlimit()`，进程可为自己消耗的各类资源设定一个上限。
此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）软限制的调整上限。
非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。
### 2.8内存映射
调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。
- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。
- 相映成趣的是并无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

某一进程所映射的内存可以与其他进程的映射共享:其一是两个进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。
- 当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见取决于创建映射时所传入的标志参数。
- 若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；
- 若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。

内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。
### 静态库和共享库
#### 静态库
静态库是对已编译目标模块的一种结构化整合。要使用静态库中的函数，需要在创建程序的链接命令中指定相应的库。
- 在不同的可执行文件中，可能都存有相同目标代码的副本，这是对磁盘空间的浪费。同理，调用同一库函数的程序，若均以静态链接方式生成，且又于同时加以执行，这会造成内存浪费，因为每个程序所调用的函数都各有一份
- 副本驻留在内存中，此其二。此外，如果对库函数进行了修改，需要重新加以编译、生成新的静态库，而所有需要调用该函数“更新版”的应用，都必须与新生成的静态库重新链接。
#### 共享库——解决静态库所存在的问题。
- 将程序链接到共享库，链接器不会把库中的目标模块复制到可执行文件中，而是在可执行文件中写入一条记录，以表明可执行文件在运行时需要使用该共享库。
- 运行时将可执行文件载入内存，名为“动态链接器”的程序会确保将可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中相应的函数定义关联起来。在运行时，共享库代码在内存中只需保留一份，且可供所有运行中的程序使用。
- 能确保各类程序及时使用到函数的最新版本，只需将带有函数新定义体的共享库重新加以编译即可，程序会在下次执行时自动使用新函数。
### 进程间通信及同步
有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制
> - 信号（signal），用来表示事件的发生。
>- 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。`|的主要作用是将一个命令的输出作为另一个命令的输入`
>- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
>- 消息队列，用于在进程间交换消息（数据包）。
>- 信号量（semaphore），用来同步进程动作。
>- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。
### 信号
内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。
在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。
收到信号时，进程会根据信号采取如下动作之一。
>-  忽略信号。
>- 被信号“杀死”。
>- 先挂起，之后再被专用信号唤醒。

大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号或者建立自己的信号处理器。信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。
# 文件 I/O：通用的 I/O 模型
4-1.c
- O_RDONLY 以只读方式打开文件
- O_WRONLY 以只写方式打开文件
- O_RDWR 以读写方式打开文件
-------
- O_CLOEXEC设置 close-on-exec 标志（自 Linux 2.6.23 版本开始）v4
- O_CREAT若文件不存在则创建之，文件以只读方式打开，还需要提供 mode 参数v3
- O_DIRECT无缓冲的输入/输出O_DIRECTORY如果 pathname 不是目录，则失败v4
- O_EXCL结合 O_CREAT 参数使用，专门用于创建文件v3
- O_LARGEFILE在 32 位系统中使用此标志打开大文件- O_NOATIME调用 read()时，不修改文件最近访问时间（自 Linux 2.6.8版本开始）
- O_NOCTTY不要让 pathname（所指向的终端设备）成为控制终端v3
- O_NOFOLLOW对符号链接不予解引用v4
- O_TRUNC截断已有文件，使其长度为零v3
-------------
- O_APPEND总在文件尾部追加数据
- O_ASYNC当 I/O 操作可行时，产生信号（signal）通知进程
- O_DSYNC提供同步的 I/O 数据完整性（自 Linux 2.6.33 版本开始）v3
- O_NONBLOCK以非阻塞方式打开v3
- O_SYNC以同步方式写入文件v3

### open()调用所返回的文件描述符数值
如果调用 open()成功，必须保证其返回值为**进程未用文件描述符中数值最小者**。可以利用该特性以特定文件描述符打开某一文件。
- O_RDONLY、O_WRONLY 和 O_RDWR 标志均在此列，调用 open()时，上述三者在 flags 参数中不能同时使用，只能指定其中一种。调用fcntl()的 F_GETFL 操作能够检索文件的访问模式（见 5.3 节）。
- 文件创建标志：这些标志在表 4-3 中位于第二部分，其控制范围不拘于 open()调用行为的方方面面，还涉及后续 I/O 操作的各个选项。这些标志**不能检索，也无法修改**。
- 已打开文件的状态标志：这些标志是表 4-3 中的剩余部分，使用 fcntl()的 F_GETFL 和F_SETFL 操作可以分别检索和修改此类标志。有时干脆将其称之为**文件状态标志**。
- 调用 open()时指定 O_ASYNC 标志没有任何实质效果。
- fork用于创建一个新的进程，父进程返回一个大于0,子进程返回0,失败返回-1
  
### open()函数的错误
- EACCES文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原因有目录权限的限制、文件不存在并且也无法创建该文件。
- EISDIR所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。
- EMFILE进程已打开的文件描述符数量达到了进程资源限制所设定的上限
- ENFILE文件打开数量已经达到系统允许的上限。
- ENOENT要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存在（空链接）。
- EROFS所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。
- ETXTBSY所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）
  
### creat()系统调用
需要<fcntl.h>
creat()系统调用根据 pathname 参数创建并打开一个文件，若文件已存在，则打开文件，并清空文件内容，将其长度清 0。creat()返回一文件描述符，供后续系统调用使用。
等价于：
```c
fd = open(pathname,O_WRONLY | O_CREAT | O_TRUNC,mode)
```
现在不太用
### 读取文件内容：read()
**从文件描述符 fd 所指代的打开文件中读取数据。**
```c
#include<unistd.h>
ssize_t read(int fd,void* buffer,size_t count);
```
- count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。
- 如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。
- 一次 read()调用所读取的字节数可以小于请求的字节数。
- 默认情况下从终端读取字符，一遇到换行符（\n），read()调用就会结束。
### 数据写入文件：write()
**将数据写入一个已打开的文件中。**
```c
#include<unistd.h>
ssize_t write(int fd,void* buffer,size_t count);
```
- write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。
- write()调用成功并不能保证数据已经写入磁盘。因为为了减少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作，
### 关闭文件：close()
**调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当一进程终止时，将自动关闭其已打开的所有文件描述符。**
```c
#include<unistd.h>
int close(int fd);
```
- 显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可读性，也更可靠
- **文件描述符属于有限资源，因此文件描述符关闭失败可能会导致一个进程将文件描述符资源消耗殆尽。**
### 改变文件偏移量：lseek()
- 每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 read()或 write()操作的文件起始位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。
- 文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按顺序递进，对文件进行操作。
- 针对文件描述符 fd 参数所指代的已打开文件，lseek()系统调用依照 offset 和 whence 参数值调整该文件的偏移量。
- offset 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型）whence 参数则表明应参照哪个基点来解释 offset 参数应为以下其中之一。
> - SEEK_SET 将文件偏移量设置为从文件头部起始点开始的 offset 个字节。
> - SEEK_CUR 相对于当前文件偏移量，将文件偏移量调整 offset 个字节 。
> - SEEK_END将文件偏移量设置为起始于文件尾部的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起。
```c
#include<unistd.h>
off_t lseek(int fd,off_t offset,int whence);
```
- lseek()并不适用于所有类型的文件。不允许将 lseek()应用于管道、FIFO、socket 或者终端。一旦如此，调用将会失败，并将 errno 置为 ESPIPE。
- O_APPEND 会导致内核忽略应用程序的文件偏移量，强制将每次写入的数据追加到文件末尾。
### 文件空洞
- 从文件结尾后到新写入数据间的这段空间被称为文件空洞.文件空洞中是存在字节的，读取空洞将返回以 0（空字节）填充的缓冲区。
- 文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。
- 文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。eg : 核心转储文件
### 通用 I/O 模型以外的操作：ioctl()
```C
#include<sys/ioctl.h>
int ioctl(int fd,int requst,.../*argp*/);
```
- fd 参数为某个设备或文件已打开的文件描述符，request 参数指定了将在 fd 上执行的控制操作。具体设备的头文件定义了可传递给 request 参数的常量。
- ioctl()调用的第三个参数采用了标准 C 语言的省略符号（...）来表示（称之为 argp），可以是任意数据类型。ioctl()根据 request 的参数值来确定 argp 所期望的类型。通常情况下，argp是指向整数或结构的指针，有些情况下，不需要使用 argp。
# 深入探究文件 I/O
### 原子操作和竞争条件
竞争状态的情形:操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程 获得 CPU 使用权的先后相对顺序
### 文件控制操作：fcntl()
```c
#include<fcntl.h>
int fcntl(int fd,int cmd,...);
```
cmd 参数所支持的操作范围很广。fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。
- [fcntl](https://blog.csdn.net/2403_86955807/article/details/144093333)
- [fcntl2](https://blog.csdn.net/wkd_007/article/details/135258634?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b24c7c990835848326b9aeb94609d714%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=b24c7c990835848326b9aeb94609d714&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-135258634-null-null.142^v100^pc_search_result_base1&utm_term=fcntl&spm=1018.2226.3001.4187)
### 打开文件的状态标志
- fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为F_GETFL。
- 可以使用 fcntl()的 F_SETFL 命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT。
### 复制文件描述符
```c
#include<unistd.h>
int dup(int oldfc);

int dup2(int oldfd,int newfd);
#define _GNU_SOURCE
int dup3(int oldfd,int newfd,int flags);
```
- dup()调用复制一个打开的文件描述符 oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。
- 再假定在正常情况下，shell 已经代表程序打开了文件描述符 01 和 2，且没有其他描述符在用，dup()调用会创建文件描述符 1 的副本，返回的文件描述符编号值为 3。如果希望返回文件描述符 2:
```C
close(2);
newfd = dup(1);
```
- 如果想进一步简化上述代码，同时总是能获得所期望的文件描述符，可以调用 dup2(),dup2()系统调用会为 oldfd 参数所指定的文件描述符创建副本，其编号由 newfd 参数指定。如果由 newfd 参数所指定编号的文件描述符之前已经打开，那么 dup2()会首先将其关闭。
- 如果 oldfd 并非有效的文件描述符，那么 dup2()调用将失败并返回错误 EBADF，且不关闭 newfd。如果 oldfd 有效，且与 newfd 值相等，那么 dup2()将什么也不做，不关闭 newfd，并将其作为调用结果返回。
### 在文件特定偏移量处的 I/O：pread()和 pwrite()
```c
#include<unistd.h>
ssize_t pread(int fd,void* buf,size_t count,off_t offset);
ssize_t pread(int fd,const void* buf,size_t count,off_t offset);
```
- 对 pread()和 pwrite()而言，fd 所指代的文件必须是可定位的（即许对文件描述符执lseek()调用）。
### 分散输入和集中输出（Scatter-Gather I/O）：readv()和 writev()
### 截断文件：truncate()和 ftruncate()系统调用
### 非阻塞 I/O
### 大文件 I/O
### 创建临时文件
### /dev/fd 目录
# 文 件 属 性
### 获取文件信息：stat()
```c
#include <sys/stat.h>
#include <unistd.h>
#include <sys/types.h>
int stat(const char path, struct stat buf);
int fstat(int fd, struct stat buf);
int lstat(const char path, struct stat *buf);
```
- stat() 系统调用只是读取文件的元数据并返回，而不会对文件的内容或元数据进行任何更改，因此它不会修改文件的访问时间 (atime)、修改时间 (mtime) 或改变时间 (ctime)。这些时间戳仅会在实际的文件内容修改、文件元数据修改或文件访问时发生变化，而不是通过 stat() 调用。
- 任何对文件的读取操作（无论是读取文件内容，还是读取元数据）都会导致 atime 更新。
# 目录与链接
- rm 命令从目录列表中删除一文件名，将相应 i-node的链接计数减一，若链接计数因此而降为 0，则还将释放该文件名所指代的 i-node 和数据块。
- **readdir()对 Linux 特有/proc/PID/fd 目录内容（内含符号链接指向进程当前打开的每个文件描述符）的扫描，可以获知一个进程当前打开了哪些文件。**
- 符号链接之间可能会形成链路（例如，a 是指向 b 的符号链接，而 b 是指向 c 的符号链接）。当在各个文件相关的系统调用中指定了符号链接时，内核会对一系列链接层层解去引用，直抵最终文件。
# 进程
### 进程和程序
进程（process）是一个可执行程序（program）的实例。程序是包含了一系列信息的文件,所包括的内容如下所示。
- 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息（metainformation）。内核（kernel）利用此信息来解释文件中的其他信息。可执行文件曾有两种广泛使用的格式，分别为最初的 `a.out`（汇编程序输出）和更加复杂的`COFF`（通用对象文件格式）。现在，大多数 UNIX 实现（包括 Linux）采用**可执行连接格式（ELF）**
- 机器语言指令：对程序算法进行编码。
- 程序入口地址：标识程序开始执行时的起始指令位置。
- 数据：程序文件包含的变量初始值和程序使用的字面常量（literal constant）值（比如字符串）。
- 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包括调试和运行时的符号解析（动态链接）。
- 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。
- 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。
### 进程号和父进程号
系统调用 getpid()返回调用进程的进程号。
每个进程都有一个进程号（PID）
```C
#include<unistd.h>
pid_t getpid(void);

pid_t getppid(void);
```
**getpid()返回值的数据类型为 pid_t,专用于存储进程号。**
每个进程都有一个创建自己的父进程。使用系统调用 getppid()可以检索到父进程的进程号。
```C
pid_t getppid(void);
```
### 进程内存布局
每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”
- 文本段包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为==多个进程可同时运行同一程序==，所以又将文本段设为可共享，这样，==一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中==。
- 初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。
- 未初始化数据段包含了未进行显式初始化的全局变量和静态变量。
- 栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。
- 堆（heap）是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作 program break。
### 虚拟内存管理

Linux运用虚拟内存管理技术。该技术利用访问局部性（locality of reference），以求高效使用 CPU 和 RAM（物理内存）资源。大多数程序都展现了两种类型的局部性。
> - **空间局部性（Spatial locality）**：是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。
> - **时间局部性（Temporal locality）**：是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。
虚拟内存管理的最后一个优点是：由于每个进程使用的 RAM 减少了，RAM 中同时可以容纳的进程数量就增多了。这增大了如下事件的概率：在任一时刻，CPU 都可执行至少一个进程，因而往往也会提高 CPU 的利用率。
### 栈和栈帧
栈驻留在内存的高端并向下增长（朝堆的方向）。专用寄存器—**栈指针（stack pointer）**，用于跟踪当前栈顶。每次调用函数时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去。
### 命令行参数
GNU C 语言库提供有两个全局变量，可在程序内任一位置使用以获取调用该程序时的程序名称（即命令行的第一个参数）。第一个全局变量program_invocation_ name，提供了用于调用该程序的完整路径名。第二个全局变量 program_invocation_ short_name，提供了不含目录的程序名称，即路径名的基本名称（basename）部分，定义_GNU_SOURCE宏后即可从<errno.h>中获得对这两个全局变量的声明。
### 环境列表
每一个进程都有与其相关的称之为**环境列表**（environment list）的字符串数组，或简称为环境（environment）。其中每个字符串都以**名称=值（name=value）**形式定义。因此，环境是“名称-值”的成对集合，可存储任何信息。常将列表中的名称称为环境变量（environment variables）。
> 在 C 语言程序中，可以使用全局变量 char **environ 访问环境列表。
getenv()函数能够从进程环境中检索单个值。
```C
#include<stdlib.h>
char* getenv(const char*name);
int putenv(char* string);
```
参数 string 是一指针，指向 name=value 形式的字符串。调用 putenv()函数后，该字符串就成为环境的一部分，putenv()函数调用失败将返回非 0 值，而非−1。
如果 string 参数内容不包含一个等号（=），那么将从环境列表中移除以 string 参数命名的环境变量。setenv()函数可以代替 putenv()函数，向环境中添加一个变量。
```C
#include<stdlib.h>
int setenv(const char*name,const *value,int overwrite);
int unsetenv(const char *name);
```
**return 0 is success ,or -1 on error**
> - setenv()函数为形如 name=value 的字符串分配一块内存缓冲区，并将 name 和 value 所指向的字符串复制到此缓冲区，以此来创建一个新的环境变量。注意，不需要（实际上，是绝对不要）在 name 的结尾处或者 value 的开始处提供一个等号字符，因为 setenv()函数会在向环境添加新变量时添加等号字符。
> - 若以 name 标识的变量在环境中已经存在，且参数 overwrite 的值为 0，则 setenv()函数将不改变环境，如果参数 overwrite 的值为非 0，则 setenv()函数总是改变环境。
```C
#define _BSD_SOURCE
#include<stdlib.h>
int clearenv(void);
```
### 执行非局部跳转：setjmp()和 longjmp()
```c
#include<setjmp.h>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env,int val);
```
对 setjmp()的调用只能在如下语境中使用。
> - 构成选择或迭代语句中（if、switch、while 等）的整个控制表达式。
> - 作为一元操作符!（not）的操作对象，其最终表达式构成了选择或迭代语句的整个控制表达式。
> - 作为比较操作（==、!=、<等）的一部分，另一操作对象必须是一个整数常量表达式，且其最终表达式构成选择或迭代语句的整个控制表达式。
> - 作为独立的函数调用，且没有嵌入到更大的表达式之中。
> - C 语言赋值语句不在上述列表之列。
# 信号：基本概念
### 概念和概述
==信号是事件发生时对进程的通知机制。有时也称之为软件中断。== 一个（具有合适权限的）进程能够向另一进程发送信号。
引发内核为进程产生信号的各类事件如下。
> 1. 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。
> 2. 用户键入了能够产生信号的终端特殊字符。其中包括中断字符（通常是 Control-C)、暂停字符（通常是 Control-Z）。
> 3. 发生了软件事件。例如，针对文件描述符的输出变为有效，调整了终端窗口大小，定时器到期，进程执行的 CPU 时间超限，或者该进程的某个子进程退出

信号分为**两大类**。第一组用于内核向进程通知事件，构成所谓传统或者标准信号。Linux 中标准信号的编号范围为 1～31。另一组信号由实时信号构成，
### 信号类型和默认行为
#### SIGABRT
当进程调用 abort()函数（21.2.2 节）时，系统向进程发送该信号。默认情况下，该信号会终止进程，并产生核心转储文件。
#### SIGALRM
经调用 alarm()或 setitimer()而设置的实时定时器一旦到期，内核将产生该信号。实时定时器是根据挂钟时间进行计时的（即人类对逝去时间的概念）。
#### SIGBUS
产生该信号（总线错误，bus error）即表示发生了某种内存访问错误。如当使用由 mmap()所创建的内存映射时，如果试图访问的地址超出了底层内存映射文件的结尾，那么将产生该错误。
#### SIGCHLD
当父进程的某一子进程终止（或者因为调用了 exit()，或者因为被信号杀死）时，（内核）将向父进程发送该信号。当父进程的某一子进程因收到信号而停止或恢复时，也可能会向父进程发送该信号。详情请参考 26.3 节。
#### SIGCLD
与 SIGCHLD 信号同义。
#### SIGCONT
将该信号发送给已停止的进程，进程将会恢复运行（即在之后某个时间点重新获得调度）。当接收信号的进程当前不处于停止状态时，默认情况下将忽略该信号。进程可以捕获该信号，以便在恢复运行时可以执行某些操作。关于该信号的更多细节请参考 22.2 节和 34.7 节。
#### SIGEMT
UNIX 系统通常用该信号来标识一个依赖于实现的硬件错误。Linux 系统仅在 Sun SPARC实现中使用了该信号。后缀 EMT 源自仿真器陷阱（emulator trap），Digital PDP-11 的汇编程序助记符之一。
#### SIGFPE
SIGHUP
当终端断开（挂机）时，将发送该信号给终端控制进程。
#### SIGILL
如果进程试图执行非法（即格式不正确）的机器语言指令，系统将向进程发送该信号。
#### SIGINFO
#### SIGINT
==当用户键入终端中断字符（通常为 Control-C）时，终端驱动程序将发送该信号给前台进程组。该信号的默认行为是终止进程。==
#### SIGIO
==利用 fcntl()系统调用，即可于特定类型（诸如终端和套接字）的打开文件描述符发生 I/O事件时产生该信号。==
#### SIGIOT
该信号名与 SIGABRT 信号同义。在其他一些 UNIX 实现中，该信号表示发生了由实现定义的硬件错误。
#### SIGKILL
此信号为“必杀（sure kill）”信号
#### SIGLOST
更多见20.2节
### 改变信号处置：signal()
```c
#include<signal.h>
void (*signal(int sig,void (*handler)(int)))(int);
void handler(int sig)
{
    //code for the handler
}
```
- 第一个参数 sig，标识希望修改处置的信号编号，第二个参数 handler，则标识信号抵达时所调用函数的地址。该函数无返回值（void），并接收一个整型参数。
- signal()的返回值是之前的信号处置。像 handler 参数一样，这是一枚指针，所指向的是带有一个整型参数且无返回值的函数。
- 使用 signal()，将无法在不改变信号处置的同时，还能获取到当前的信号处置。要想做到这一点，必须使用 sigaction()
signal()原型可以改写成如下形式：
```C
sighandler_t signal(int sig ,sighandler_t handler);
```
在为 signal()指定 handler 参数时，可以以如下值来代替函数地址：
> 1. SIG_DFL
> 2. SIG_IGN
### 发送信号：kill()
与 shell 的 kill 命令相类似，一个进程能够使用 kill()系统调用向另一进程发送信号。
```c
#include<signal.h>
int kill(pid_t pid,int sig);
```
解释 pid，要视以下 4 种情况而定。
> - 如果 pid 大于 0，那么会发送信号给由 pid 指定的进程。
> - 如果 pid 等于 0，那么会发送信号给与调用进程同组的每个进程，包括调用进程自身
> - 如果 pid 小于−1，那么会向组 ID 等于该 pid 绝对值的进程组内所有下属进程发送信号。
> - 如果 pid 等于−1，那么信号的发送范围是：调用进程有权将信号发往的每个目标进程，除去 init（进程 ID 为 1）和调用进程自身。
### 发送信号的其他方式：raise()和 killpg()
有时，进程需要向自身发送信号（34.7.3 节就有此一例）。raise()函数就执行了这一任务。
```c
#include<signal.h>
int raise(int sig);
int killpg(pid_t pgrp,int sig);
```
单线程程序中，调用 raise()相当于对 kill()的如下调用
```c
kill(getpid(),sig);
```
支持线程的系统会将 raise(sig)实现为：
```c
pthread_kill(pthread_self(),sig);
```
psignal()函数（在标准错误设备上）所示为 msg 参数所给定的字符串，后面跟有一个冒号，随后是对应于 sig 的信号描述。和 strsignal()一样，psignal()函数也对本地设置敏感。
```c
#include<signal.h>
void psignal(int sig,const char*msg);
```
### 信号集
1. 必须使用 sigemptyset()或者 sigfillset()来初始化信号集。
2. 信号集初始化后，可以分别使用 sigaddset()和 sigdelset()函数向一个集合中添加或者移除单个信号。
3. sigismember()函数用来测试信号 sig 是否是信号集 set 的成员。如果 sig 是 set 的一个成员，那么 sigismember()函数将返回 1（true）
，否则返回 0（false）。
4. GNU C 库还实现了 3 个非标准函数，是对上述信号集标准函数的补充。
```C
#include<signal.h>
int signemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set,int sig);
int sigdelset(sigset_t *set,int sig);
int sigismember(sigset_t *set, int signo);
// 如果是返回1，如果不是，返回0，如果给定的信号无效，返回-1；
```
```c
#define _GNU_SOURCE
#include <signal.h>
int sigandset(sigset_t *set,sigset_t *left,sigset_t *right);
int sigorset(sigset_t *dset,sigset_t *left,sigset_t *right);
int sigisemptyset(const sigset_t *set);
```
- sigandset()将 left 集和 right 集的交集置于 dest 集。
- sigorset()将 left 集和 right 集的并集置于 dest 集。
- 若 set 集内未包含信号，则 sigisemptyset()返回 true。

printSigset()显示了指定信号集的成员信号。
### 信号掩码（阻塞信号传递）
向信号掩码中添加一个信号，有如下几种方式。
- 当调用信号处理器程序时，可将引发调用的信号自动添加到信号掩码中。是否发生这一情况，要视 sigaction()函数在安装信号处理器程序时所使用的标志而定。
- 使用 sigaction()函数建立信号处理器程序时，可以指定一组额外信号，当调用该处理器程序时会将其阻塞。
- 使用 sigprocmask()系统调用，随时可以显式向信号掩码中添加或移除信号。
```C
int sigprocmask(int how,const sigset_t *set,sigset_t *oldset);
```
- 若oset是非空指针，那么进程的当前信号屏蔽字通过oset返回
- 若set是非空指针，那么参数how指示如何修改当前信号屏蔽字
- > SIG_BLOCK：将set指向的包含了希望阻塞的信号集，与当前信号屏蔽字，相并，或操作
SIG_UNBLOCK：将set指向的包含了希望阻塞的信号集的补集，与当前信号屏蔽字，相交，与操作
SIG_SETMASK：将当前的信号集合设置为set指向的信号集，赋值操作
-  如果set是空指针，那么不改变进程的信号屏蔽字，how无意义

如果解除了对某个信号的锁定，那么会立刻将该信号传递给进程，系统将忽略试图阻塞SIGKILL和SIGSTOP信号的请求，如果试图阻塞，sigprocmask既不会处理，也不会产生错误，这意味着，可以使用如下方式阻塞除了SIGKILL和SIGSTOP之外的所有信号：
> // 使用blockset(包含所有信号)初始化信号集
sigfillset(&blockset);
// 将所有信号阻塞，但实际无法阻塞SIGKILL和SIGSTOP
if (-1 == sigprocmask(SIG_BLOCK, &blockset, NULL))
    perror("sigprocmask error");

### 处于等待状态的信号
返回的信号集由参数set返回，对于调用进程而言，其中的各个信号是阻塞不能传递的，因而一定是当前未决的；如果某进程接受了一个该进程正在阻塞的信号，那么会将该信号添加到进程的等待信号集中，当解除了对该信号的锁定时，随之将信号传递给此进程
```C
#include <signal.h>

int sigpending(sigset_t *set);
// 返回值：若成功，返回0，若出错，返回-1
```
### 不对信号进行排队处理
如果同一信号在阻塞状态下产生多次，那么会将该信号记录在等待信号集中，稍后仅传递一次；即使进程没有阻塞信号，其收到的信号可能比发送给它的要少得多，如果信号发送速度如此之快，以至于内核考虑将执行权调度给接收进程前，这些信号已经到达，就会发生这种情况
### 改变信号处置：sigaction
sigaction较之于signal，允许在获取信号处置的同时无需将其改变，还可以设置各种属性对调用信号处理程序时的行为控制的更加精确，可移植性也更加：
```C
#include <signal.h>

int sigaction(int signo, conststruct sigaction*restrict act, struct sigaction*restrict oact);
// 若成功，返回0，若出错，返回-1
// signo是除去SIGKILL和SIGSTOP之外的任何信号

struct sigaction{
  void (*sa_handler)(int);
  sigset_t sa_mask;
  int sa_flag;
  void (*sa_sigaction)(int, siginfo_t*, void*);
};
// sa_handler对应于signal的handler参数，是信号处理函数的地址，或者是常量SIG_IGN、SIG_DFL之一
// 仅当sa_handler是信号处理函数的地址，即SIG_IGN、SIG_DFL之外的取值，才会对sa_mask和sa_flag加以处理
// sa_sigaction和sa_handler，在应用中只能一次使用其中之一

sa_flag的选项：
SA_INTERRUPT: 由此信号中断的系统调用不自动重启动
SA_NOCLDSTOP: 若signo是SIGCHLD，当子进程停止，不产生此信号，当子进程终止，仍旧产生此信号，若已设置此标志，当停止的进程继续运行时，不产生SIGCHLD信号
SA_NOCLDWAIT:若signo是SIGCHLD，当调用进程的子进程终止时，不创建僵死进程，当调用进程随后调用wait，则阻塞到它所有子进程都终止
SA_NODEFER: 当捕捉到此信号执行其信号处理函数时，系统不自动阻塞此信号，应用于早期不可靠信号
SA_ONSTACK: XSI
SA_RESETHAND: ...
SA_RESTART: 由此信号中断的系统调用自动重启动
SA_SIGINFO: 对信号处理程序提供了附加信息：一个指向siginfo的指针以及指向上下文的context指针
```
- signo是要检测或修改的信号编号
- 若act非空，则修改其动作，若oact非空，则系统经由oact返回该信号的上一个动作
一般信号处理程序调用：
```C
void handler(int signo);
```
如果设置sa_flag为SA_SIGINFO，则调用：
```C
void handler(int signo, siginfo_t *info, void *context)
```
