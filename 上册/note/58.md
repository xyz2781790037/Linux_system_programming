# 第58章 SOCKET：TCP/IP 网络基础

### 互联网

机器 tekapo 是一种路由器，它一台将一个子网络连接到另一个子网络并在它们之间传输数据的计算机。除了需要理解所使用的互联网协议之外，一台路由器还必须要理解它连接的各个子网所使用的（可能）不同的数据链路层协议。

一台路由器拥有多个网络接口，每个接口都连接到一个子网上。更通用的术语“多宿主机”用来指拥有多个网络接口的任意主机——不必是一台路由器。（另一种描述路由器的方式是说它是将包从一个子网转发到另一个子网的一台多宿主机。）一个多宿主机的各个接口上的网络地址是不同的（即其
连接的各个子网的地址是不同的）。

![使用一台路由器连接
两个网络的互联网](/home/zgyx/.config/Typora/typora-user-images/image-20250313081232042.png)

### 联网协议和层

TCP/IP 协议套件是一个分层联网协议它包括因特网协议（IP）和位于其上层的各个协议层名字 TCP/IP 是从传输控制协议（TCP）是使用最为广泛的传输层协议这样一个事实而得出来的。

协议分层如此强大和灵活的其中一个原因是透明——每一个协议层都对上层隐藏下层的
操作和复杂性如：

- 一个使用 TCP 的应用程序只需要使用标准的 socket API 并清楚自己正在使用一项可靠的字节流传输服务，而无需理解 TCP 操作的细节
- 应用程序也无需知道 IP 和数据链路层的操作细节。

##### 封装

低层不会尝试对高层发送过来的信息进行解释，而只会将这些信息放到低层所使用的包中并在将这个包向下传递到低层之前添加自身这一层的头信息。当数据从低层传递到高层时将会进行一个逆向的解包过程。

![IP/TCP](https://aetherance.github.io/res/TCP-IP.png)

封装的概念还延伸到了数据链路层，其中 IP 数据报会被封装进网络帧中封装可能还会延伸到应用层中，其中应用程序可能会按照自己的方式对数据进行打包。

![封装](https://img-blog.csdn.net/20130521203323714)

### 数据链路层

最低层是数据链路层，它由设备驱动和到底层物理媒介（如电话线、同轴电缆、或光纤）的硬件接口（网卡）构成

数据链路层关注的是在一个网络的物理链接上传输数据

传输数据，数据链路层需要将网络层传递过来的数据报封装进被称为帧的一个一个单元。除了需要传输的数据之外，每个帧都会包含一个头，如头中可能包含了目标地址和帧的大小。

- **封装与帧**：将网络层的数据报封装成**帧**进行传输。
- **帧结构**：每个帧包含**头部**（如目标地址、帧大小）和**数据**。
- **传输与确认**：在物理链路上传输帧，并可能处理**确认**（部分数据链路层不使用确认）。
- **错误控制**：可能包含**错误检测、重传、流量控制**。
- **分片与重组**：可能将**大数据包分片**为多个帧，并在接收端**重组**。
- **应用层视角**：应用程序通常**无需关注数据链路层**，通信细节由**驱动和硬件**处理。

数据链路层中比较重要的一个特点是**最大传输单元（MTU）。**
数据链路层的 MTU 是该层所能传输的帧大小的上限。**不同的数据链路层的 MTU 是不同的。**

### 网络层：IP

网络层关注的是如何将包（数据）从源主机发送到目标主机。这一层执行了很多任务，包括以下几个：

- 将数据分解成足够小的片段以便数据链路层进行传输（如有必要的话）。

- 在因特网上路由数据。

- 为传输层提供服务。

##### IP协议的两个版本

IPv4地址由32位二进制数组成，可表示约43亿地址。为方便阅读，IPv4地址可用点分十进制表示。如`192.168.0.1`

IPv4目前是主流的IP表示方案，但也存在着能够表示的地址不够的问题。

IPv6解决了这一问题。其地址为128位的二进制数，可以表示约`3.4×10³⁸`地址个地址。

IPv6的头部为固定的40字节，每个设备都可以有公网地址。IPv6的地址还可以表示为十六进制冒号分隔的形式 如 `2001:0db8:85a3::8a2e:0370:7334`。

IPv4 和 IPv6 都支持高层的 UDP 和 TCP 传输层协议

图 58-2 给出了一个裸 socket（SOCK_RAW），它允许应用程序直接与 IP 层进行通信。这里不会对裸 socket 的使用进行描述，因为大多数应用程序会使用基于其中一种传输层协议（TCP或 UDP）之上的 socket。

##### IP 传输数据报

IP 以数据报（包）的形式来传输数据。一个 IP 数据报包含一个头，其大小范围为 20 字节到 60 字节。这个头中包含了目标主机的地址还包含了包的源地址，这样接收主机就知道数据报的源头。

IP 实现可能会给它所支持的数据报的大小设定一个上限所有 IP 实现都必须做到数据报的大小上限至少与规定的 IP 最小重组缓冲区大小一样大

在 IPv4 中，这个限制值是 576 字节；在 IPv6 中，这个限制值是 1500 字节。

##### IP 是无连接和不可靠的

> 无连接：IP协议在发送数据之前不会建立连接。
>
> 不可靠：IP协议不保证数据按顺序到达，不保证数据不重复，也不保证数据不丢失。

IP协议会通过IP地址标识网络中的设备，在一个网络中，设备的IP地址是唯一的。

IP协议会根据网络最大传输单元(MTU)拆分数据包，并在接收端重组。

IP会将数据包封装成有固定20字节头部的数据包

##### IP 可能会对数据报进行分段

大多数数据链路层会为数据帧的大小设定一个上限（MTU）

当一个 IP 数据报的大小大于 MTU 时，IP 会将数据报分段（分解）成一个个大小适合在网络上传输的单元。这些分段在达到最终目的地之后会被重组成原始的数据报。

每个 IP 分段本身就是包含了一个偏移量字段的 IP 数据报，该字段给出了一个该分段在原始数据报中的位置。

IP 分段的发生对于高层协议层是透明的

一些 IPv4 地址拥有特殊的含义。特殊地址 127.0.0.1 一般被定义为回环地址，它通常会被分配给主机名 localhost。

为允许 IPv6 应用程序与只支持 IPv4 的主机进行通信，IPv6 提供了所谓的 IPv4 映射的 IPv6地址

![IPv4 映射的 IPv6 地址的格式](/home/zgyx/.config/Typora/typora-user-images/image-20250313091336442.png)

在书写 IPv4 映射的 IPv6 地址时，地址的 IPv4 部分（即最后 4 个字节）会被书写成 IPv4的 点 分 十 进 制 标 记 。 因 此 与 204.152.189.116 等 价 的 IPv4 映 射 的 IPv6 地 址是::FFFF:204.152.189.116。

### 传输层

在 TCP/IP 套件中使用广泛的两个传输层协议如下。

- 用户数据报协议（UDP）是数据报 socket 所使用的协议。
- 传输控制协议（TCP）是流 socket 所使用的协议。

#### 端口号

端口号是16位整数（0~65535），用于**标识主机上的应用程序进程**，使传输层能够将数据准确递交给目标应用。

- **类比**：IP地址相当于“大楼地址”，端口号相当于“房间号”。

- **特权端口（Well-Known Ports）**：0~1023，分配给系统级服务。
  - 示例：HTTP（80）、HTTPS（443）、FTP（21）、SSH（22）。
- **注册端口（Registered Ports）**：1024~49151，分配给用户应用程序。
  - 示例：MySQL（3306）、Redis（6379）。
- **动态/私有端口（Dynamic/Ephemeral Ports）**：49152~65535，客户端临时使用。

- **多路复用与分用**：通过端口号区分同一主机上的不同应用。
- **网络地址转换（NAT）**：端口号在NAT中用于映射内网主机。

#### **TCP**

##### 1. 核心特性

- **面向连接**：通过**三次握手**建立可靠连接，**四次挥手**终止连接。
- **可靠传输**：通过确认（ACK）、重传、序列号机制保证数据无丢失、无重复、按序到达。
- **流量控制**：滑动窗口机制动态调整发送速率，避免接收方缓冲区溢出。

- **拥塞控制**：通过慢启动、拥塞避免、快速重传等算法适应网络状况。
- 数据会被分解成段，每一个段都包含一个校验和，从而能够检测出端到端的传输错误。每一个段使用单个 IP 数据报来传输。

##### 2. 报文结构

TCP头部包含关键字段：

- **序列号（Sequence Number）**：标识数据字节流的顺序。
- **确认号（Acknowledgment Number）**：期望接收的下一个字节序号。
- **窗口大小（Window Size）**：接收方的可用缓冲区大小。
- **标志位（Flags）**：SYN（建立连接）、ACK（确认）、FIN（终止连接）等。

##### 3. 应用场景

- **可靠性要求高**的场景：网页浏览（HTTP/HTTPS）、文件传输（FTP）、电子邮件（SMTP）。

![tcp](https://aetherance.github.io/res/tcp-connect.png)

使用TCP协议的发送方和接收方各维护了一个滑动窗口。 通过这两个滑动窗口TCP可以实现流量控制和拥塞控制。

##### 确认、重传以及超时

为处理段永远不到达或被丢弃的情况，发送者在发送每一个段时会开启一个定时器。如果在定时器超时之前没有收到确认，那么就会重传这个段。

由于所使用的网络以及当前的流量负载会影响传输一个段和接收其确认所需的时间，因此 TCP 采用了一个算法来动态地调整**重传超时时间**（`RTO`）的大小。

接收 TCP 可能不会立即发送确认，而是会等待几毫秒来观察一下是否可以将确认塞进接收者返回给发送者的响应中。（每个 TCP 段都包含一个确认字段，这样就能将确认塞进TCP 段中了。）这项被称为延迟 ACK 的技术的目的是能少发送一个 TCP 段，从而降低网络中包的数量以及降低发送和接收主机的负载。

##### 流量控制

流量控制防止一个快速的发送者将一个慢速的接收者压垮。要实现流量控制，接收 TCP就必须要为进入的数据维护一个缓冲区。（每个 TCP 在连接建立阶段会通告其缓冲区的大小。）

TCP 流量控制算法采用了所谓的滑动窗口算法，它允许包含总共 N 字节（提供的窗口大小）的未确认段同时在发送者和接收者之间传输。

##### 拥塞控制：慢启动和拥塞避免算法

TCP 的拥塞控制算法被设计用来防止快速的发送者压垮整个网络。

| 场景             | 早期TCP行为                | 现代TCP行为                                   |
| ---------------- | -------------------------- | --------------------------------------------- |
| **连接建立后**   | 立即发送rwnd允许的所有数据 | 通过慢启动逐步增加发送速率（cwnd从1开始增长） |
| **空闲恢复传输** | 直接按原有窗口发送         | 重置cwnd，重新慢启动                          |
| **网络适应性**   | 高风险（可能压垮网络）     | 自适应（平衡效率和稳定性）                    |

TCP 的拥塞控制策略组合采用了两种算法：**慢启动和拥塞避免。**

- 慢启动算法会使发送 TCP 在一开始的时候以低速传输分段，但同时允许它以指数级的速度提高其速率，只要这些分段都得到接收 TCP 的确认。
- 连接刚建立时，发送 TCP 会使用一个较小的拥塞窗口，它会限制所能传输的未确认的数据数量当发送者从对等 TCP 处接收到确认时，拥塞窗口在一开始时会呈现指数级增长。但一旦拥塞窗口增长到一个被认为是接近网络传输容量的阈值时，其增长速度就会变成线性，而不是指数级的。

#### **UDP**

UDP在 IP 之上添加了两个特性：端口号和一个进行检测传输数据错误的数据校验

##### 核心特性

- **无连接**：无需建立连接，直接发送数据。
- **不可靠传输**：不保证数据到达顺序、是否丢失或重复。
- **低开销**：头部仅8字节（源端口、目的端口、长度、校验和）。
- **支持广播/多播**：可同时向多个主机发送数据。

##### 2. 报文结构

UDP头部仅包含：

- 源端口、目的端口（各2字节）。
- 数据报长度（2字节）。
- 校验和（可选，用于错误检测）。

##### **扩展知识**

1. **TCP的粘包与拆包**：应用层需处理TCP流式传输中的消息边界问题。
2. **UDP的可靠性增强**：QUIC（基于UDP的HTTP/3协议）通过应用层实现可靠传输。
3. **端口扫描**：通过探测端口状态判断主机运行的服务（如Nmap工具）。

#### TCP**拥塞控制**

##### **拥塞控制的目标**

1. **避免网络过载**：防止过多数据同时涌入网络，导致路由器缓冲区溢出。
2. **公平性**：多个TCP连接共享网络带宽时，应公平分配资源。
3. **高效性**：在避免拥塞的同时，尽可能提高网络吞吐量。

##### **核心概念**

**拥塞窗口（Congestion Window, cwnd）**

- 发送方维护的一个动态窗口，表示当前网络允许的最大未确认数据量。
- **实际发送窗口** = min(cwnd, 接收方的通告窗口)。

**慢启动阈值（ssthresh）**

- 一个动态阈值，用于区分慢启动阶段和拥塞避免阶段。
- 初始值通常较高（如网络最大窗口），在拥塞发生后会被重置。

**网络拥塞的信号**

- **超时重传（Timeout）**：严重拥塞（如路由器队列满，大量丢包）。
- **重复ACK（Duplicate ACKs）**：轻微拥塞（少量丢包）。

##### **TCP拥塞控制算法**

经典算法包含 **4个阶段**：慢启动、拥塞避免、快速重传、快速恢复。现代TCP（如Reno、CUBIC、BBR）在此基础上改进。

### **拥塞控制 vs 流量控制**

| 特性         | 拥塞控制                   | 流量控制                           |
| ------------ | -------------------------- | ---------------------------------- |
| **目标**     | 防止网络过载（全局性问题） | 防止接收方缓冲区溢出（端到端问题） |
| **信号来源** | 网络丢包、延迟             | 接收方的窗口大小（rwnd）           |
| **调整对象** | 拥塞窗口（cwnd）           | 发送窗口（swnd = min(cwnd, rwnd))  |
| **机制**     | 慢启动、拥塞避免、快速恢复 | 滑动窗口、ACK确认机制              |